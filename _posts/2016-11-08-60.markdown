---
layout: post
title:  "【更新到5】Project Eulor Problem 1-26,30"
date:   2016-11-08 22:28:17 +0800
categories: 技术
tags: projecteulor java c
use_code: true

---
至少我以前做过2波欧拉，当然也是各种搁置。

主要和以前的代码相比，就是修改了下格式，偶尔加上一两句吐槽。

这里是以前在sina blog上面贴过的解答，主要发现在公司居然不能上sina blog，而且上面的代码格式太不堪入目了，所以有空就整理下。

偶尔看看自己以前写的代码也很有意思，特别是一些C的代码

<!--more-->

--------

## euler project:problem 1 ##
2013-02-01 09:52:09

If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000. 

10以内约数为3或5的数有3、5、6和9，它们的和是23。求1000以内的约数3或5的数的和。

    int sum = 0;
    int h = 1000;  
    for(int i = 1; i < h ; i++) {
        if(i % 5 == 0) {
            sum += i;
        } else if(i % 3 == 0){
            sum+=i;  
        }
    }
    System.out.println(sum);

下面这个解法应该是我去看了讨论贴之后的比较奥数的解法

    System.out.println((3+(h-1)/3*3)*((h-1)/3)/2+(5+(h-1)/5*5)*((h-1)/5)/2-(15+(h-1)/15*15)*((h-1)/15)/2); 
    
--------

## euler project:problem 2斐波那契 ##
2013-02-01 10:11:20

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms. 

斐波那契数列中，每一项的数值是其前两项数之和，从1和2开始，前10项斐波那契数列是： 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... 求斐波那契数列中项值不小于4000000的偶数数项之和。

    #include<stdio.h>
    int fb(int i)
    {  
        if(i == 1 || i == 2)
            return 1;
        else
            return fb(i - 1) + fb(i - 2);
    }

    int main()
    {
        int sum = 0;
        int i = 1;
        for(;;i++)
        {  
            if(fb(i) > 4000000)
                break;
            if(fb(i) % 2 == 0)
                sum += fb(i);
        }

        printf("%d\n", sum);
        return 0;
    }

这题开始从C解了，我记得当时大多数的题目我都用的C解而不是java。

而且当时的题目我记得是没有标题的，小标题都是我自己加上的，如果想加的话。系统后台也没有记录是什么时候解的。

--------

## euler project:problem 3质因数 ##
2013-02-01 10:22:19

The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600851475143 ?

13195的素数约数为5、7、13和29 求600851475143的最大素数约数

    #include <stdio.h>
    #include <math.h>

    int isPrime(long i)
    {  
        long long j = 2;
        if(i == 2)
        {  
            return 1;
        }
        
        for(; j < sqrt(i); j ++)
        {  
            if(i % j == 0)
            {  
                return 0;
            }
        }

        return 1;
    }

    int main()
    {  
        long long i = 2;
        long long largest = 0;
        long long number = 600851475143;
        for(; i <= number; i++)
        {
            if(isPrime(i) == 1)
            {
                if(number % i == 0)
                {
                    largest = i;
                    number /= i;
                    printf("%lld,", i);
                }
            }
        }
        printf("\n%lld", largest);
        return 0;
    }

我差点就去查费马小定理了，以为花了太多时间在验证是不是素数上面了，发现还是number/=i没有用上。

--------

## euler project:problem 4回文数 ##
2013-02-01 10:48:18

A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91*99.

Find the largest palindrome made from the product of two 3-digit numbers.

一个数如果从前往后和从后往前念都相同，那么它就是回文数。

由两个两位数相乘组成的最大回文数是9009= $$ 91*99 $$ 。

求由两个三位数相乘组成的最大回文数。

    #include <stdio.h>

    int isPalindromic(int number)
    {
        int i = number, result = 0;  
        for(; i != 0; i /= 10)
            result = result * 10 + i;
        return result == number;  
    }

    int main()
    {
        int og1 = 1000, og2, result = 0;
        for(; og1 > 99; og1--)
            for(og2 = og1; og2 > 99; og2--)
                if(isPalindromic(og1 * og2))
                    if(og1 * og2 > result)
                        result = og1 * og2;
        printf("%d\n",result); 
    } 

--------

## euler project:problem 5最小公倍数 ##
2013-02-01 11:09:08

2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.

What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

求1～20的最小公倍数

    #include<stdio.h>
    
    long long GCD(long long a,long long b)
    {
        if(b==0)
        {
            return a;
        }  
        else
        {
            return GCD(b,a%b);
        }
    }
    
    long long LCM( long long a,long long b)  
    {  
        return a*b/GCD(a,b);  
    }  
    
    int main()  
    {  
        long long i=2,result=1;
        for(;i<=20;i++)  
        {  
            result=LCM(result,i);  
        }  
        
        printf("%lld\n",result);  
    } 

输出结果之后再

    printf("%d\n",2*2*3*5*11*13*7*4*17*3*19 );

两数最小公倍数等于两数之积除以最大公约数。虽然我是wiki搜到的公式，但是能够理解。

其实最大公约数也是wiki搜到的算法，没看懂。如果要短除求最大公约和最小公倍貌似我还记得，不过当时老师也只是教了方法没说为什么。

2┃11 12 13 14 15 16 17 18 19 20

　┗━━━━━━━━━━━━━━━━
 
2┃11 6 13 7 15 8 17 9 19 10

　┗━━━━━━━━━━━━━━━━
 
3┃11 3 13 7 15 4 17 9 19 5

　┗━━━━━━━━━━━━━━━━
 
5┃11 1 13 7 5 4 17 3 19 5

　┗━━━━━━━━━━━━━━━━
 
 　11 1 13 7 1 4 17 3 19 1
  
结果= $$ 2*2*3*5*11*13*7*4*17*3*19 $$

c的long long你妹啊！
